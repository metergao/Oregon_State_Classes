\documentclass[letterpaper,10pt,notitlepage,fleqn]{article}

\usepackage{nopageno} %gets rid of page numbers
\usepackage{alltt}                                           
\usepackage{float}
\usepackage{color}
\usepackage{url}
\usepackage{balance}
\usepackage[TABBOTCAP, tight]{subfigure}
\usepackage{enumitem}
\usepackage{pstricks, pst-node}
\usepackage{geometry}
\geometry{textheight=9in, textwidth=6.5in} %sets 1" margins 
\newcommand{\cred}[1]{{\color{red}#1}} %command to change font to red
\newcommand{\cblue}[1]{{\color{blue}#1}} % ...blue
\usepackage{hyperref}
\usepackage{textcomp}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}

\def\name{Sam Quinn}

\parindent = 0.0 in
\parskip = 0.2 in

\title{Project 4 Write Up}
\author{Sam Quinn}

\begin{document}
\maketitle
\hrule

\section*{Design}

\subsection*{pro.prime.c and thr.prime.c Programs}
These programs will find the total number of primes up to a given number with the supplied number of threads or process. This program can theoretically calculate the primes up to the size of an unsigned long but I have only tested it to the size of an unsigned int. These programs will also find the happy prime numbers up to the same number.

\textbf{Threaded Version}
\begin{itemize} 
\item if no options/arguments, print usage
\item -n is the max prime, will find all primes up to this number.
\item -i will set the max prime to size of an int, will find all primes up to this number.
\item -u will set the max prime to size of an unsigned int, will find all primes up to this number.
\item -t will set the number of threads to use.
\item -v will print the results to the terminal (NOT recommended to exceed 10,000 as for the printing process takes a lot of time.)
\item -m If defined in the command line no mutexes will be used.
\end{itemize}

\textbf{ Process Version}
\begin{itemize} 
\item if no options/arguments, print usage
\item -n is the max prime, will find all primes up to this number.
\item -i will set the max prime to size of an int, will find all primes up to this number.
\item -u will set the max prime to size of an unsigned int, will find all primes up to this number.
\item -p will set the number of processes to use.
\item -v will print the results to the terminal (NOT recommended to exceed 10,000 as for the printing process takes a lot of time.)

\end{itemize}


\subsection*{Functions of Program Details}

% Generated with LaTeXDraw 2.0.8
% Tue Nov 26 21:15:54 PST 2013
% \usepackage[usenames,dvipsnames]{pstricks}
% \usepackage{epsfig}
% \usepackage{pst-grad} % For gradients
% \usepackage{pst-plot} % For axes
\scalebox{1} % Change this value to rescale the drawing.
{
\begin{pspicture}(0,-8.17)(18.12,8.166)
\definecolor{color594b}{rgb}{0.611764705882353,0.6745098039215687,0.8274509803921568}
\psframe[linewidth=0.04,dimen=outer,fillstyle=solid,fillcolor=color594b](7.46,2.85)(3.94,1.17)
\usefont{T1}{ptm}{m}{n}
\rput(1.4090625,7.5460935){Start}
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(1.38,6.9010935)(1.38,6.4010935)
\psframe[linewidth=0.04,dimen=outer](2.8,6.481094)(0.0,5.2810936)
\usefont{T1}{ptm}{m}{n}
\rput(1.3446875,6.115){Get Max Number}
\psdiamond[linewidth=0.04,dimen=outer](1.4,7.52)(0.98,0.65)
\usefont{T1}{ptm}{m}{n}
\rput(1.3098438,5.715){System or User}
\psframe[linewidth=0.04,dimen=outer](6.52,4.9010935)(3.46,3.61)
\usefont{T1}{ptm}{m}{n}
\rput(4.9660935,4.455){Run Seirial Version}
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(2.779623,5.9305654)(3.8403769,5.929435)
\usefont{T1}{ptm}{m}{n}
\rput(4.9798436,5.935){Start Timer}
\psframe[linewidth=0.04,dimen=outer](6.02,6.29)(3.86,5.53)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(4.82,5.55)(4.84,4.83)
\psframe[linewidth=0.04,dimen=outer](16.62,2.27)(13.72,1.43)
\usefont{T1}{ptm}{m}{n}
\rput(11.967188,3.015){Clear Non-Primes}
\usefont{T1}{ptm}{m}{n}
\rput(15.150937,1.875){Bitmap}
\psline[linewidth=0.04cm](6.54,4.45)(11.82,4.47)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(11.82,4.49)(11.82,3.29)
\usefont{T1}{ptm}{m}{n}
\rput(1.3475,4.575){Fork or Pthread}
\usefont{T1}{ptm}{m}{n}
\rput(1.3257812,4.135){User Defined \#}
\psframe[linewidth=0.04,dimen=outer](2.68,4.93)(0.0,3.81)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(3.480131,4.440713)(2.7198691,4.439287)
\usefont{T1}{ptm}{m}{n}
\rput(5.19,4.015){Until $\sqrt{\sqrt{Max}}$}
\usefont{T1}{ptm}{m}{n}
\rput(5.7482815,1.815){Thread/Procsess}
\psellipse[linewidth=0.04,dimen=outer](5.76,1.81)(1.36,0.4)
\usefont{T1}{ptm}{m}{n}
\rput(5.757344,0.355){Calc Start Stop}
\psframe[linewidth=0.04,dimen=outer](7.12,0.91)(4.42,-0.09)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(5.78,1.39)(5.8,0.87)
\usefont{T1}{ptm}{m}{n}
\rput(8.7025,1.815){Sieve Process}
\psline[linewidth=0.04cm](7.14,0.51)(8.66,0.51)
\psframe[linewidth=0.04,dimen=outer](9.84,2.25)(7.64,1.41)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(8.66,0.51)(8.68,1.37)
\pscircle[linewidth=0.04,dimen=outer](11.09,0.72){0.83}
\usefont{T1}{ptm}{m}{n}
\rput(11.0875,1.015){Lock}
\usefont{T1}{ptm}{m}{n}
\rput(11.080156,0.475){Unlock}
\psline[linewidth=0.04cm](9.42,1.41)(9.42,0.53)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(9.42,0.53)(10.28,0.53)
\usefont{T1}{ptm}{m}{n}
\rput(5.7034373,2.575){\# of Threads/Process }
\psline[linewidth=0.04cm](2.34,3.81)(2.36,2.07)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(2.36,2.07)(3.94,2.07)
\usefont{T1}{ptm}{m}{n}
\rput(1.0771875,-1.125){Count Primes}
\usefont{T1}{ptm}{m}{n}
\rput(2.7498438,-0.045){Stop Timer}
\usefont{T1}{ptm}{m}{n}
\rput(1.2759376,1.235){If All Finished}
\psframe[linewidth=0.04,dimen=outer](2.58,1.77)(0.04,0.69)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(3.96,1.35)(2.56,1.35)
\psframe[linewidth=0.04,dimen=outer](3.8,0.31)(1.72,-0.37)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(2.32,0.71)(2.34,0.25)
\psframe[linewidth=0.04,dimen=outer](2.26,-0.81)(0.02,-1.55)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(0.3,0.69)(0.34,-0.83)
\psline[linewidth=0.04cm](2.3,-1.17)(15.72,-1.19)
\usefont{T1}{ptm}{m}{n}
\rput(15.893907,-0.065){Count non Cleared}
\usefont{T1}{ptm}{m}{n}
\rput(15.7760935,-0.525){Numbers}
\psframe[linewidth=0.04,dimen=outer](17.38,0.19)(14.42,-0.81)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(15.7,-1.19)(15.72,-0.81)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(15.78,0.15)(15.8,1.49)
\psframe[linewidth=0.04,dimen=outer](13.4,3.33)(10.48,2.65)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(11.14,1.51)(11.14,2.67)
\psline[linewidth=0.04cm](13.4,3.05)(15.32,3.05)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(15.3,3.03)(15.32,2.23)
\usefont{T1}{ptm}{m}{n}
\rput(1.4275,-2.505){Fork or Pthread}
\usefont{T1}{ptm}{m}{n}
\rput(1.3557812,-2.945){User Defined \#}
\psframe[linewidth=0.04,dimen=outer](2.76,-2.15)(0.08,-3.27)
\psframe[linewidth=0.04,dimen=outer,fillstyle=solid,fillcolor=color594b](7.46,-2.19)(3.94,-3.87)
\usefont{T1}{ptm}{m}{n}
\rput(5.7482815,-3.225){Thread/Procsess}
\psellipse[linewidth=0.04,dimen=outer](5.76,-3.23)(1.36,0.4)
\usefont{T1}{ptm}{m}{n}
\rput(5.7034373,-2.465){\# of Threads/Process }
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(1.02,-1.53)(1.02,-2.17)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(2.74,-2.91)(3.94,-2.89)
\usefont{T1}{ptm}{m}{n}
\rput(5.637344,-4.865){Calc Start Stop}
\psframe[linewidth=0.04,dimen=outer](7.0,-4.31)(4.3,-5.31)
\psline[linewidth=0.04cm](7.02,-4.71)(9.94,-4.69)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(5.66,-3.63)(5.68,-4.37)
\psline[linewidth=0.04cm](16.62,1.83)(18.1,1.81)
\psline[linewidth=0.04cm](18.1,1.79)(18.1,-1.57)
\psline[linewidth=0.04cm](18.1,-1.57)(10.22,-1.55)
\usefont{T1}{ptm}{m}{n}
\rput(10.153906,-2.745){Check Mood}
\psframe[linewidth=0.04,dimen=outer](11.36,-2.35)(9.0,-3.51)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(10.24,-1.55)(10.24,-2.41)
\usefont{T1}{ptm}{m}{n}
\rput(10.131406,-3.205){With Primes}
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(9.94,-4.71)(9.96,-3.51)
\usefont{T1}{ptm}{m}{n}
\rput(1.2759376,-4.085){If All Finished}
\psframe[linewidth=0.04,dimen=outer](2.58,-3.55)(0.04,-4.63)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(3.96,-3.73)(2.58,-3.75)
\usefont{T1}{ptm}{m}{n}
\rput(1.2023437,-6.205){Count Happy}
\psframe[linewidth=0.04,dimen=outer](2.46,-5.81)(0.04,-6.69)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(1.12,-4.63)(1.1,-5.85)
\psline[linewidth=0.04cm](2.46,-6.27)(14.74,-6.27)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(14.74,-6.27)(14.72,-3.23)
\usefont{T1}{ptm}{m}{n}
\rput(14.508594,-2.845){\# Happy}
\psframe[linewidth=0.04,dimen=outer](15.5,-2.49)(13.78,-3.21)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(11.34,-2.83)(13.74,-2.87)
\usefont{T1}{ptm}{m}{n}
\rput(12.424375,-2.665){If Happy}
\usefont{T1}{ptm}{m}{n}
\rput(1.0404687,-7.885){Return 0}
\psframe[linewidth=0.04,dimen=outer](1.8,-7.49)(0.3,-8.17)
\psline[linewidth=0.04cm,arrowsize=0.05291667cm 2.0,arrowlength=1.4,arrowinset=0.4]{->}(1.08,-6.69)(1.08,-7.49)
\end{pspicture} 
}




\subsubsection*{Finding Primes}

\begin{itemize}
\item Receive number from user.
\item Run a serial version of Sieve only to the $\sqrt{\sqrt{Number}}$
\item Spawn threads or processes giving each thread/process its number.
\item Calculate what numbers that process needs to work with.
\item Find the first prime with in the range calculated above.
\item First square the prime and mark it as not prime.
\item Then add 2$\ast$prime to the previous number and mark as not prime too.
\item Continue this process until the thread/process has iterated through its work load.
\end{itemize}

The user will either choose an arbitrary number or use one of the predefined numbers from the command line which will be set as a global variable so every function can access it with out needing to pass it around. I stored weather the number is prime or not in a bitmap that defines every odd number as prime at first. This bitmap excludes every even number because except for 2 no even number is prime. When spawning threads or processes I send the number of thread/process it is with that thread/process. The benefit of the thread/process knowing what number it is that with in each thread/process they calculate their beginning and ending range to work on. Each thread/process has a different section of numbers to work on with the last thread/process`s max being the $\sqrt{Max}$. I have the work split up so theoretically no thread/process should run in to each other$\ast$. Each thread/process will run in parallel using the Sieve of Eratosthenes formula to find all of the non primes under the number. 

\textbf{Note$\ast$} \\
However there is still a race case that comes from different non primes while getting marked off as non prime try to access the same part of the bitmap.

\subsubsection*{Finding Happy Numbers}       
 
\begin{itemize}
\item Spawn the amount of threads/process that the user decided
\item Calculate the work space start and end number for that process
\item Read from the bit map and for every prime it finds check if it is happy or not.
\end{itemize}

This function uses the work already done from the find primes function to determine if the prime is happy or sad. It will use the same process to determine the work space for each thread/process as in the find primes function. Since we have already weeded out the non primes this function will scan through the bitmap and check only the primes to determine their mood.



 
\section*{Work Log}

\begin{verbatim}
commit 68590883a43a78b4be79f5191160cf29d1e54e3d
Author: Sam Quinn <quinnsa@os-class.engr.oregonstate.edu>
Date:   Wed Nov 27 20:59:59 2013 -0800
\end{verbatim}
    Final commit. It has been good homework. I think I let you pro\_prime.c get the best of me, but you guys have done me good. Farewell, see you soon during the demo. Till then Peace my brothers!
\begin{verbatim}
commit 2dc1be6628162d334ef4f50d9c60adee3a36ae32
Author: Sam Quinn <quinnsa@os-class.engr.oregonstate.edu>
Date:   Wed Nov 27 20:04:01 2013 -0800
\end{verbatim}
    Just going through and making everything look purty for submission.

\begin{verbatim}
commit e0bee53c8fea364bfc573cb2a418ea87a82dc212
Author: Sam Quinn <quinnsa@os-class.engr.oregonstate.edu>
Date:   Wed Nov 27 10:46:53 2013 -0800
\end{verbatim}
    So I was actually wrong about being able to get rid of my mutexes it was just a coincidence that i got the right number 3 times in a row with out mutexes. I still need them.
    In this version of the threaded version I added a few more command line arguments like -v to print the primes and happy numbers and -m to run the program with out mutexes. mainly for timing purposes I don't want to have to wait around for 3-4 minutes ever time I run the dang thing.

\begin{verbatim}
commit 87ff777a1aecbd4b4900dc929f9b826c23108095
Author: Sam Quinn <quinnsa@os-class.engr.oregonstate.edu>
Date:   Tue Nov 26 23:42:36 2013 -0800
\end{verbatim}
    Oh yeah!!!!! I just found the reason why my code was going so slow! while working with my happy numbers function it wasnt working with my next prime function and i found the part of code that was producing race cases. I was only returning the next prime up to the Sqrt(max) not all the way up to the max. This allowed me to get rid of my mutexes which bring my runtime down from 300+ seconds to a nice number like 32! Wooohoo this is good man!

\begin{verbatim}
commit f6df108ef06abb657a37dd187c61ed9b387bdb51
Author: Sam Quinn <quinnsa@os-class.engr.oregonstate.edu>
Date:   Tue Nov 26 19:13:55 2013 -0800
\end{verbatim}
    Minor fixes on my threaded function just a few house keeping things. My process version of the program I for some reason for the life of me can't get my semaphores working it is really frustrating because after I get that working I am pretty much done.

\begin{verbatim}
commit d0156bbdc3e98fb81ed70edc8d717b9b31f3891c
Author: Sam Quinn <quinnsa@os-class.engr.oregonstate.edu>
Date:   Mon Nov 25 12:51:16 2013 -0800
\end{verbatim}
    Threaded version -- pretty much works great still very slow since i have to use mutexes. I how ever did split the mutexes up into 20 separate ones so in theory there can be 20 separate access to the bitmap at a time but it still slows it down exponentially.
    
    Process version -- Have not made much progress since last commit am pretty much solely working on that now since my threaded version works well.

\begin{verbatim}
commit 68fdd6dfd8213852ac06a7a50929bd274b67194a
Author: Sam Quinn <quinnsa@os-class.engr.oregonstate.edu>
Date:   Sun Nov 24 18:41:44 2013 -0800
\end{verbatim}
    Threaded process works still no happy function though. Added the process version of the program.

\begin{verbatim}
commit 77099cc69c5371340011edee1a8ca8b6d85ee504
Author: Sam Quinn <quinnsa@os-class.engr.oregonstate.edu>
Date:   Fri Nov 22 16:46:51 2013 -0800
\end{verbatim}
    My threaded program works! have not implemented counting happy or sad numbers yet. It is also very very slow 10 minutes to calculate UINT\_MAX :(

\begin{verbatim}
commit bb9d94d4815a1283b179f8c498149c2a8dd6deec
Author: Sam Quinn <quinnsa@os-class.engr.oregonstate.edu>
Date:   Thu Nov 21 00:31:29 2013 -0800
\end{verbatim}
    My threaded version works pretty well for values under 10,000 for some reason after that it becomes buggy.

\begin{verbatim}
commit 6a675cb19a7f7be52bb969b0aece7ab3a58544b5
Author: Sam Quinn <quinnsa@os-class.engr.oregonstate.edu>
Date:   Wed Nov 20 00:34:22 2013 -0800
\end{verbatim}
    Coming along I have multiple threads working and i have made beginning and end points for each thread to calculate with.

\begin{verbatim}
commit 6a9534ea07e72985119e6f6769f40614ded7a58d
Author: Sam Quinn <quinnsa@os-class.engr.oregonstate.edu>
Date:   Mon Nov 18 07:58:29 2013 -0800
\end{verbatim}
    Got my bitmap kind of working I need to add one because some numbers had a floating point decimal which makes the last bit not change.

\begin{verbatim}
commit 169c9830aa749b5303e3578b206b539b1e481018
Author: Sam Quinn <quinnsa@os-class.engr.oregonstate.edu>
Date:   Sun Nov 17 19:45:20 2013 -0800
\end{verbatim}
    Initial commit nothing really works yet!


\section*{Timings}


\begin{table}[ht] 
\caption{Threaded Model Results} % title of Table 
\centering % used for centering table 
\begin{tabular}{ c c c c c} % centered columns (4 columns) 
\hline\hline %inserts double horizontal lines 
Max Number & 10 Threads & 32 Threads & 200 Threads & 500 Threads\\ [0.5ex] % inserts table 
%heading 
\hline % inserts single horizontal line 
1,000,000 & 0 & 0 & 0 & 0 \\
100,000,000 & 4 & 3 & 3 & 4 \\ 
1,000,000,000 & 37 & 31 & 32 & 33 \\
2,147,483,647 & 90 & 85 & 76 & 73 \\ 
4,294,967,295 & 260 & 229 & 250 & 273 \\% inserting body of the table 
[1ex] % [1ex] adds vertical space 
\hline %inserts single line 
\end{tabular} 
\label{table:nonlin} % is used to refer this table in the text 
\end{table} 

For my Process version every time I ran the program I got a 0.00 second reading. So I have omitted the table of this program as it would be filled with 0.00's.


\section*{Challenges Overcame}
This program brought on a lot of frustration with both versions of the program. It was hard for me to get my program under 45 seconds. I heard a few people in class saying they got their functions to work with out using any sort of IPC, I however could never get mine to work without some sort of resource locking. In both versions of my program I have race cases on bitmap when two or more threads/processes are trying to write to the same word. This frustrated me so much is that if i get rid of the mutexes my programs runtime drops from around 230 seconds to 32 seconds. I also had a difficult time getting my semaphores working on my process version of the program. I know that you can use an unnamed semaphore if you set the pshared int to greater than 0, which I did, but for the life of me couldn't get the unnamed semaphores to work across multiple unrelated processes. The way I solved this problem was I ended up using a named semaphore which worked with out having to change much of my code. I had a very hard time getting the process version of this program working correctly. I had troubles the whole way through from creating a shared memory object to getting the right outputs. I thought this version of the program would have been easy since I have already used forking and multiple processes in past assignments, but this was not the case. I found the implicit sharing much easier to wrap my head around and far easier to implement. I am very disappointed with my self for not getting my process version working to the point i would like. 

    
\end{document}
